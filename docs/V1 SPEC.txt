
OLD!!!!

╔══════════════════╗
║ APHELION ISA 1.0 ║ by technichron
╚══════════════════╝

══ GENERAL ══

 » 8-bit word length
 » 16-bit address (64kb addressable memory)

══ MEMORY ══

    NAME             │ RANGE
    ─────────────────┼───────────────
    ROM*             │ 0x0000-0x8FFF
    RAM              │ 0x9000-0xFFF0
    PROGRAM COUNTER* │ 0xFFF1-0xFFF2    // high at 0xFFF1, low at 0xFFF2
    RESERVED**       │ 0xFFF3-0xFFFE
    STDOUT / IN      │ 0xFFFF-0xFFFF

    *  protected - these regions cannot be directly written to
    ** unsafe - if using any compound instructions, any data here may be overwritten

══ REGISTERS ══

    NAME │ DESCRIPTION                                   │ INTERNAL ID
    ─────┼───────────────────────────────────────────────┼─────────────
    A    │ general                                       │ 0b000
    B    │ general                                       │ 0b001
    C    │ general                                       │ 0b010
    D    │ general                                       │ 0b011
    E    │ general / reserved*                           │ 0b100
    L    │ general / 16b argument low register           │ 0b101
    H    │ general / 16b argument high register          │ 0b110
    F    │ flags - 000[carry][borrow][equal][less][zero] │ 0b111

    * unsafe - if using any compound instructions, any data here may be overwritten

══ INSTRUCTIONS ══

    IDENTIFIER │ ARGUMENTS                           │ DESCRIPTION
    ───────────┼─────────────────────────────────────┼─────────────────────────────────────────────────
    NOP        │ N/A                                 │ no instruction
    SET        │ reg1, (reg2/imm8)                   │ reg1 (reg2/imm8)
    LOAD       │ reg, (HL/imm16)                     │ load reg with value at address (HL/imm16)
    SAVE       │ reg, (HL/imm16)                     │ store value in reg at address (HL/imm16)
    DSAVE  *   │ imm8, (HL/imm16)                    │ store imm8 at address (HL/imm16)
    ADD      † │ reg1, (reg2/imm8)                   │ reg1 = reg1 + (reg2/imm8)
    ADC      † │ reg1, (reg2/imm8)                   │ reg1 = reg1 + (reg2/imm8) + carry
    SUB      † │ reg1, (reg2/imm8)                   │ reg1 = reg1 - (reg2/imm8)
    SBB      † │ reg1, (reg2/imm8)                   │ reg1 = reg1 - (reg2/imm8) - borrow
    JMP        │ (HL/label/imm16)                    │ PC = (HL/imm16)
    JNZ      † │ reg, (HL/label/imm16)               │ PC = (HL/imm16) if reg != 0
    JEZ    * † │ reg, (HL/label/imm16)               │ PC = (HL/imm16) if reg == 0
    JEQ    * † │ reg1, (reg2/imm8), (HL/label/imm16) │ PC = (HL/imm16) if reg1 == reg2
    JNE    * † │ reg1, (reg2/imm8), (HL/label/imm16) │ PC = (HL/imm16) if reg1 != reg2
    JLT    * † │ reg1, (reg2/imm8), (HL/label/imm16) │ PC = (HL/imm16) if reg1 < reg2
    JGT    * † │ reg1, (reg2/imm8), (HL/label/imm16) │ PC = (HL/imm16) if reg1 > reg2
    JLE    * † │ reg1, (reg2/imm8), (HL/label/imm16) │ PC = (HL/imm16) if reg1 <= reg2
    JGE    * † │ reg1, (reg2/imm8), (HL/label/imm16) │ PC = (HL/imm16) if reg1 >= reg2
    AND        │ reg1, (reg2/imm8)                   │ reg1 = reg1 & (reg2/imm8)
    OR         │ reg1, (reg2/imm8)                   │ reg1 = reg1 | (reg2/imm8)
    NOT        │ reg                                 │ reg = !reg
    CMP      † │ reg1, (reg2/imm8)                   │ compare reg1 to (reg2/imm8) and set flags
    HCF        │ N/A                                 │ halt and catch fire
    
    * compound instruction - does not have a corresponding opcode, but expanded into core instructions by the assembler
      see "compoundexpansion.txt" for how these instructions expand.
    † modifies flags