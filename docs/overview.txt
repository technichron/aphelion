╔══════════════════╗
║ APHELION ISA 2.0 ║ by technichron
╚══════════════════╝

8-bit word length
little-endian
16-bit address space

MEMORY

    ROM         0x0000-0x8FFF
    RAM         0x9000-0xFFF0
    RESERVED    0xFFF1-0xFFFE
    STDIO       0xFFFF-0xFFFF



REGISTERS (8-bit)

    0x00  A  general
    0x01  B  general
    0x02  C  general
    0x03  D  general
    0x04  E  general
    0x05  F  flags                               00[carry][borrow][greater][equal][less][zero]
    0x06  G  general   UNSAFE                  * recommended for use w/ macro unpacking
    0x08  IL general - low  byte of I
    0x18  IH general - high byte of I
    0x09  JL general - low  byte of J
    0x19  JH general - high byte of J
    0x0A  KL general - low  byte of K
    0x1A  KH general - high byte of K
    0x0B  PL program counter - low  byte of P
    0x1B  PH program counter - high byte of P
    0x0C  SL stack pointer - low  byte of S
    0x1C  SH stack pointer - high byte of S
    0x0D  RL return pointer - low  byte of R
    0x1D  RH return pointer - high byte of R
    0x0E  XL general / function argument - low  byte of X
    0x1E  XH general / function argument - high byte of X
    0x0F  YL general / function argument - low  byte of Y
    0x1F  YH general / function argument - high byte of Y
 


DOUBLE REGISTERS (16-bit)

    0x08  I  general
    0x09  J  general
    0x0A  K  general
    0x0B  P  program counter
    0x0C  S  stack pointer   * initialized to the top of ram, 0xFFF0
    0x0D  R  return pointer
    0x0E  X  general / function argument
    0x0F  Y  general / function argument



INSTRUCTIONS    * this is an overview. see 'assembly.txt' for a comprehensive reference.

    nop                         no operation
    mov (src), (dest)           copy data from (src) to (dest)
    out (op)                 †  put value out to stdout; simple alias for `mov (op), 0xFFFF`
    in (reg)                 †  get value out from stdout; simple alias for `mov 0xFFFF, (reg)`
    add (op1), (op2)            (op1) = (op1) + (op2)
    adc (op1), (op2)            (op1) = (op1) + (op2) + CARRY
    sub (op1), (op2)            (op1) = (op1) - (op2)
    sbb (op1), (op2)            (op1) = (op1) - (op2) - BORROW
    jmp (loc)                 † set P to (loc)
    call (loc)                † set P to (loc) and set R to address of the following instruction
    jif (flags), (loc)          set P to (loc) if F & (flags) == (flags)
    cif (flags), (loc)          set P to (loc) and set R to address of the following instruction if F & (flags) == (flags)
    ret                         set P to return pointer
    push (value)                push (value) onto stack         * stack pointer decrements, most significant byte of int16 pushed first
    pop (dest)                  pop value from stack to (dest)  * stack pointer increments
    and (op1), (op2)            (op1) = (op1) & (op2)
    or (op1), (op2)             (op1) = (op1) | (op2)
    not (op)                    (op) = ! (op)
    cmp (op1), (op2)            compare (op1) and (op2), set relevant flags
    scmp (op1), (op2)           compare (op1) and (op2) as signed integers (two's complement), set relevant flags
    shl (op), (amount)          logical/arithmetic bit shift left (amount) bits     * can also be called with 'asl' and 'lsl'
    asr (op), (amount)          arithmetic bit shift (op) right (amount) bits
    lsr (op), (amount)          logical bit shift (op) right (amount) bits
    hcf                         halt and catch fire
    jez (loc)                †  jump to (loc) if ZERO is set
    jnz (loc)                †  jump to (loc) if ZERO is not set    * can also be called with 'jens'
    jeq (loc)                †  jump to (loc) if EQUAL is set
    jne (loc)                †  jump to (loc) if EQUAL is not set
    jlt (loc)                †  jump to (loc) if LESS is set
    jgt (loc)                †  jump to (loc) if GREATER is set
    jle (loc)                †  jump to (loc) if LESS or EQUAL is set
    jge (loc)                †  jump to (loc) if GREATER or EQUAL is set
    cez (loc)                †  call (loc) if ZERO is set
    cnz (loc)                †  call (loc) if ZERO is not set
    ceq (loc)                †  call (loc) if EQUAL is set
    cne (loc)                †  call (loc) if EQUAL is not set
    clt (loc)                †  call (loc) if LESS is set
    cgt (loc)                †  call (loc) if GREATER is set
    cle (loc)                †  call (loc) if LESS or EQUAL is set
    cge (loc)                †  call (loc) if GREATER or EQUAL is set
    nand (op1), (op2)        †  (op1) = ! ((op1) & (op2))
    xor (op1), (op2)         †  (op1) = (op1) ⊕ (op2)
    xnor (op1), (op2)        †  (op1) = ! ((op1) ⊕ (op2))
    jeans                    †  print ascii jeans to stdout     * funny

    † macro instructions

